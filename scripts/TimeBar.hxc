import funkin.play.PlayState;
import funkin.modding.module.Module;
import funkin.Paths;
import flixel.FlxSprite;
import funkin.Conductor;
import flixel.FlxG;
import flixel.text.FlxText;
import flixel.ui.FlxBar;
import flixel.math.FlxMath;
import flixel.util.FlxStringUtil;
import flixel.text.FlxTextBorderStyle;
import funkin.Preferences;
import flixel.util.FlxColor;
import openfl.geom.Rectangle;
import openfl.utils.ByteArrayData;

class TimeBar extends Module {

    var songPercentage:Float;

    var timeBarBG:FlxSprite;
    var timeBar:FlxBar;
    var timeBarEmptyColour = 0xFF000000;
    var timeBarFillColour = 0xFFFFFFFF;

    var timeText:FlxText;
    var timeTextColour = 0xFFFFFFFF;
    var timeTextOutlineColour = 0xFF000000;
    var playerStrumline;
    
    var debugtext:FlxSprite;

    var iconColour;
    var byteReader:ByteArrayData;

    function new (){
        super("timeBarMod");
    }
  

    override function onStateChangeEnd(event)
    {
        super.onStateChangeEnd(event);

   
        if (Std.isOfType(event.targetState, PlayState))
        {
            playerStrumline = PlayState.instance.playerStrumline;


            debugtext = new FlxText();
            debugtext.cameras = [PlayState.instance.camHUD];
            debugtext.size = 18;
            debugtext.updateHitbox();
            debugtext.setPosition(30, FlxG.height - debugtext.height - 10);
            debugtext.zIndex = 1000;
            PlayState.instance.add(debugtext);

     
            switch (FlxG.save.data.timebarcolour)
            {
                case "Opponent Icon":
                    findIconColour(PlayState.instance.iconP2);
                    timeBarFillColour = iconColour;
                case "Player Icon":
                    findIconColour(PlayState.instance.iconP1);
                    timeBarFillColour = iconColour;
            }
        
    
            if (FlxG.save.data.timebar != "Off")
            {
                initTimebar();
                setTimeBar();
            }
            showText();
            resetVariables();

     

       
        }
    }
 
    override function onUpdate(event)
    {
            super.onUpdate(event);

            if (PlayState.instance != null)
            {
                if (FlxG.sound.music != null)
                {
                    songPercentage = (Conductor.instance.songPosition / FlxG.sound.music.length);
                }

                if (timeBarBG != null)
                {
                    timeBar.value = songPercentage;
                }
                if (timeText != null)
                {
                    updateTimeText();
                }

            
            }
    }

    // ------ Custom Functions

    function initTimebar()
    {
        timeBarBG = new FlxSprite();
        switch (FlxG.save.data.timebar)
        {
            case "On":
                timeBarBG.loadGraphic(Paths.image("timebar"));
            case "Wide":
                timeBarBG.loadGraphic(Paths.image("widetimebar"));
        }
        timeBarBG.camera = PlayState.instance.camHUD;
        timeBarBG.zIndex = 1001;

        timeBar = new FlxBar(100, 0, "LEFT_TO_RIGHT", timeBarBG.width - 8, timeBarBG.height - 8, this, "songPercentage", 0, 1);
        timeBar.createFilledBar(timeBarEmptyColour, timeBarFillColour);
        timeBar.camera = PlayState.instance.camHUD;
        timeBar.zIndex = 1002;

        PlayState.instance.add(timeBarBG);
        PlayState.instance.add(timeBar);
    }

    function setTimeBar()
    {
        switch (FlxG.save.data.timebarpos)
        {
            case "Right":
                verticalTimeBar();
            case "Left":
                verticalTimeBar();
            case "Strumline":
                timeBarBG.setPosition(playerStrumline.x + (playerStrumline.width / 2) - (timeBarBG.width / 2), (timeBarBG.height / 2) - 4);

                if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
                {
                    timeBarBG.y = (FlxG.height - timeBarBG.height) - 4;
                }
                timeBar.setPosition(timeBarBG.x + 4, timeBarBG.y + 4);
            case "Force Middle":
                forceMiddlePosition();
            case "Top":
                defaultTimeBarPosition();
            default:
                defaultTimeBarPosition();
        }
    }

    function defaultTimeBarPosition()
    {
        if (playerStrumline.x == (FlxG.width / 2) - (playerStrumline.width / 2))
        {
            forceMiddlePosition();
            return;
        }
        timeBarBG.setPosition((FlxG.width / 2 - timeBar.width / 2) - 50 , 10);
        if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
        {
            timeBarBG.y = FlxG.height - (timeBarBG.height) - (timeBarBG.height / 2);
        }
        timeBar.setPosition(timeBarBG.x + 4, timeBarBG.y + 4);

    }

    function forceMiddlePosition()
    {
        timeBarBG.setPosition((FlxG.width / 2) - (timeBarBG.width / 2), timeBarBG.height / 2);

        if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
        {
            timeBarBG.y = FlxG.height - (timeBarBG.height) - (timeBarBG.height / 2);
        }

        timeBar.setPosition(timeBarBG.x + 4, timeBarBG.y + 4);
    }

    function showText()
    {
        timeText = new FlxText();
        timeText.text = "0:00";

        timeText.setFormat(Paths.font("vcr.ttf"), 32, timeTextColour, "center", FlxTextBorderStyle.OUTLINE, timeTextOutlineColour);
        timeText.borderSize = 2;
        timeText.setPosition(timeBarBG.x + (timeBarBG.width / 2) - (timeText.width / 2), timeBarBG.y + (timeBarBG.height / 2) - (timeText.height / 2));
        timeText.camera = PlayState.instance.camHUD;
        timeText.zIndex = 1003;

        PlayState.instance.add(timeText);
        
    }

    function updateTimeText()
    {
        switch (FlxG.save.data.timebarmode)
        {
            case "None":
                timeText.text = "";
            case "Time Elapsed":
                if (Conductor.instance.songPosition >= 0)
                {
                    timeText.text = FlxStringUtil.formatTime(Conductor.instance.songPosition / 1000, false);
                }
            case "Time Left":
                if (FlxG.sound.music != null)
                {
                    timeText.text = "" + FlxStringUtil.formatTime((FlxG.sound.music.length - FlxG.sound.music.time) / 1000, false);
                }
            case "Song Name":
                timeText.text = PlayState.instance.currentSong.songName;
            case "Song Name + Difficulty":
                timeText.text = PlayState.instance.currentSong.songName + " - " + FlxStringUtil.toTitleCase(PlayState.instance.currentDifficulty);

        }

                
        switch (FlxG.save.data.timeTextPos)
        {
            case "Default":
                if (FlxG.save.data.timebarpos == "Right")
                {
                    if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
                    {
                        timeText.setPosition(timeBarBG.x - timeText.width, timeBarBG.y - timeText.height);
                    }
                    else
                    {
                        timeText.setPosition(timeBarBG.x - timeText.width, timeBarBG.y + timeBarBG.width);
                    }
                }
                else if (FlxG.save.data.timebarpos == "Left")
                {
                    timeText.setPosition(timeBarBG.x - timeBarBG.height, timeBarBG.y + timeBarBG.width);

                    if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
                    {
                        timeText.y = timeBarBG.y - timeText.height;
                    }
            
                }
                else
                {
                    timeText.setPosition(timeBarBG.x + (timeBarBG.width / 2) - (timeText.width / 2), timeBarBG.y + (timeBarBG.height / 2) - (timeText.height / 2));
                }
            case "Strumline":
                if (FlxG.save.data.timebarpos != "Strumline")
                {
                    if (Preferences.downscroll || Preferences.controlsScheme == "Arrows")
                    {
                        timeText.setPosition(playerStrumline.x + (playerStrumline.width / 2) - (timeText.width / 2), (FlxG.height - timeText.height) - 4); //(playerStrumline.y + playerStrumline.height - (timeText.height / 2)) + 4)
                    }
                    else
                    {
                        timeText.setPosition(playerStrumline.x + (playerStrumline.width / 2) - (timeText.width / 2), (timeText.height / 2) - 4);
                    }
                }
          
        }
   
    }

    function resetVariables()
    {
        timeBar.value = 0;
        songPercentage = 0;
    }
    

    function verticalTimeBar()
    {

        if (FlxG.save.data.timebarpos == "Right")
        {
            timeBarBG.setPosition(FlxG.width - (timeBarBG.height / 2), (FlxG.height / 2) - (timeBarBG.width / 2));
        }
        else if (FlxG.save.data.timebarpos == "Left")
        {
            timeBarBG.setPosition(timeBarBG.height * 1.5, (FlxG.height / 2) - (timeBarBG.width / 2));
        }
        timeBarBG.origin.set(0, 0);
        timeBarBG.angle = 90;

        timeBar.setPosition(timeBarBG.x - 4, timeBarBG.y + 4);
        timeBar.origin.set(0, 0);
        timeBar.angle = 90;
        timeBar.flipX = true;

    

    }

    function findIconColour(icon)
    {
        var colorArray = [];
        var lightestColour = 0;
        if (icon != null)
        {
            var ypos = 0;
            var xpos = 0;
            // Try to get the colours
            for (i in 0...30)
            {
                iconColour = icon.pixels.getPixel(xpos,ypos);
                   
                debugtext.text = "Found colour " + iconColour;
                if (iconColour != 0 && !colorArray.contains(iconColour) && iconColour != 16777215)
                {
                    // debugtext.text = "Found colour " + iconColour;
                    colorArray.push(iconColour);
                }
                if (ypos < 50)
                {
                    ypos += 5;
                }
                xpos += 5;
            }
            // Find the lightest colour
            if (colorArray != [])
            {
                for (i in 0...colorArray.length)
                {
                    if (colorArray[i] > lightestColour)
                    {
                        iconColour = colorArray[i];
                        lightestColour = colorArray[i];
                    }
                }

            }
            else
            {
                iconColour = 16777215;
            }   
      
            
            debugtext.text = "Found colour " + iconColour + " Colour array " + colorArray;
            iconColour = FlxColor.fromString(FlxColor.toHexString(iconColour, false));
        }
    }

}
