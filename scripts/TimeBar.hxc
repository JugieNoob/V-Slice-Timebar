import funkin.play.PlayState;
import funkin.modding.module.Module;
import funkin.Paths;
import flixel.FlxSprite;
import funkin.Conductor;
import flixel.FlxG;
import flixel.text.FlxText;
import flixel.ui.FlxBar;
import flixel.math.FlxMath;
import flixel.util.FlxStringUtil;
import flixel.text.FlxTextBorderStyle;
import funkin.Preferences;

class timeBar extends Module {

    var songPercentage:Float;

    var timeBarBG:FlxSprite;
    var timeBar:FlxBar;
    var timeBarEmptyColour = 0xFF000000;
    var timeBarFillColour = 0xFFFFFFFF;

    var timeText:FlxText;
    var timeTextColour = 0xFFFFFFFF;
    var timeTextOutlineColour = 0xFF000000;
    var playerStrumline;

    function new (){
        super("timeBarMod");
    }
  

    function onStateChangeEnd(event)
    {
        super.onStateChangeEnd(event);

        if (Std.isOfType(event.targetState, PlayState))
        {
            playerStrumline = PlayState.instance.playerStrumline;
    
            initTimebar();
            showText();
            verticalTimeBar();
            resetVariables();

        }
    }
    // override function onCountdownStart(event)
    // {
    //     super.onCountdownStart(event);

    //     // if (PlayState.instance.isInCutscene)
    //     // {
    //     //     return;
    //     // }
    //     songPercentage = 0;
    //     var playerStrumline:FlxSprite = PlayState.instance.playerStrumline;

    //     if (FlxG.save.data.timeBar)
    //     {
    //         inittimeBar();
    //         if (FlxG.save.data.customtimeBar)
    //         {
    //             customtimeBar();
    //         }


    //         switch (FlxG.save.data.timeBarpos)
    //         {

            
    //             case "Top":

    //                 timeBar.setPosition((FlxG.width / 2 - timeBar.width / 2) - 50 , 10);

    //                 if (playerStrumline.x == FlxG.width / 2 - playerStrumline.width / 2 || PlayState.instance.currentSong == "Song(blazin)")
    //                     {
    //                         timeBar.x = (FlxG.width / 2) - (timeBar.width / 2);
    //                     }
       

    //                 if (Preferences.downscroll)
    //                     {
    //                         timeBar.y = FlxG.height - timeBar.height - 10;
    //                     }

    //                 timeBarBG.setPosition(timeBar.x - 4, timeBar.y - 4);
    //             case "Right":
    //                 verticalTimeBar();
    //             case "Force Middle":
    //                 timeBar.setPosition( (FlxG.width / 2) - (timeBar.width / 2), 10);

    //                 if (Preferences.downscroll)
    //                 {
    //                     timeBar.y = FlxG.height - timeBar.height - 10;
    //                 }
    //                 timeBarBG.setPosition(timeBar.x - 4, timeBar.y - 4);

    

    //         }

    //         switch (FlxG.save.data.timeBarmode)
    //         {
    //             case "None":
                
    //             case "Time Elapsed":
    //                 showTime();
                
    //             case "Time Left":
    //                 showTime();
                
    //         }


 
    //     }



    // }



    override function onUpdate(event)
    {
            super.onUpdate(event);

            if (PlayState.instance != null)
            {
                if (FlxG.sound.music != null)
                {
                    songPercentage = (Conductor.instance.songPosition / FlxG.sound.music.length);
                }

                if (timeBarBG != null)
                {
                    timeBar.value = songPercentage;
                }
                if (timeText != null)
                {
                    updateTimeText();
                }
            }
    }

    // ------ Custom Functions

    function initTimebar()
    {
        timeBarBG = new FlxSprite();
        timeBarBG.loadGraphic(Paths.image("timebar"));
        if (Preferences.downscroll)
        {
            timeBarBG.setPosition((FlxG.width / 2) - (timeBarBG.width / 2), FlxG.height - (timeBarBG.height) - (timeBarBG.height / 2));
        }
        else
        {
            timeBarBG.setPosition((FlxG.width / 2) - (timeBarBG.width / 2), timeBarBG.height / 2);
        }
        timeBarBG.camera = PlayState.instance.camHUD;
        timeBarBG.zIndex = 1001;

        timeBar = new FlxBar(100, 0, "LEFT_TO_RIGHT", timeBarBG.width - 8, timeBarBG.height - 8, this, "songPercentage", 0, 1);
        timeBar.setPosition(timeBarBG.x + 4, timeBarBG.y + 4);
        timeBar.createFilledBar(timeBarEmptyColour, timeBarFillColour);
        timeBar.camera = PlayState.instance.camHUD;
        timeBar.zIndex = 1002;

        PlayState.instance.add(timeBarBG);
        PlayState.instance.add(timeBar);
    }

    function showText()
    {
        timeText = new FlxText();
        timeText.text = "0:00";

        timeText.setFormat(Paths.font("vcr.ttf"), 32, timeTextColour, "center", FlxTextBorderStyle.OUTLINE, timeTextOutlineColour);
        timeText.borderSize = 2;
        timeText.setPosition(timeBarBG.x + (timeBarBG.width / 2) - (timeText.width / 2), timeBarBG.y + (timeBarBG.height / 2) - (timeText.height / 2));
        timeText.camera = PlayState.instance.camHUD;
        timeText.zIndex = 1003;


        // switch (FlxG.save.data.timeBarpos)
        // {
        //     case "Right":
        //         timeText.setPosition(FlxG.width - timeText.width - 10, timeBar.y - timeBar.width / 2 - 30);
        //     default:
        //         timeText.setPosition(timeBar.x + timeBar.width / 2 - timeText.width / 2, timeBar.y - 7);
        // }
        PlayState.instance.add(timeText);
        
    }

    function updateTimeText()
    {
        switch (FlxG.save.data.timebarmode)
        {
            case "None":
                timeText.text = "";
            case "Time Elapsed":
                if (Conductor.instance.songPosition >= 0)
                {
                    timeText.text = FlxStringUtil.formatTime(Conductor.instance.songPosition / 1000, false);
                }
            case "Time Left":
                if (FlxG.sound.music != null)
                {
                    timeText.text = "" + FlxStringUtil.formatTime((FlxG.sound.music.length - FlxG.sound.music.time) / 1000, false);
                }
            case "Song Name":
                timeText.text = PlayState.instance.currentSong.songName;
            case "Song Name + Difficulty":
                timeText.text = PlayState.instance.currentSong.songName + " - " + FlxStringUtil.toTitleCase(PlayState.instance.currentDifficulty);

        }

        



       

            

        // timeText.text = "" + Conductor.instance.songPosition;
        
        switch (FlxG.save.data.timeTextPos)
        {
            case "Default":
                if (FlxG.save.data.timebarpos == "Right")
                {
                    if (Preferences.downscroll)
                    {
                        timeText.setPosition(timeBarBG.x - timeText.width, timeBarBG.y - timeText.height);
                    }
                    else
                    {
                        timeText.setPosition(timeBarBG.x - timeText.width, timeBarBG.y + timeBarBG.width);
                    }
                }
                else
                {
                    timeText.setPosition(timeBarBG.x + (timeBarBG.width / 2) - (timeText.width / 2), timeBarBG.y + (timeBarBG.height / 2) - (timeText.height / 2));
                }
            case "Strumline":
                if (Preferences.downscroll)
                {
                    timeText.setPosition(playerStrumline.x + (playerStrumline.width / 2) - (timeText.width / 2), (playerStrumline.y + playerStrumline.height + timeText.height) + 4);
                }
                else
                {
                    timeText.setPosition(playerStrumline.x + (playerStrumline.width / 2) - (timeText.width / 2), (timeText.height / 2) - 4);
                }
        }
   
        // timeText.setPosition(timeBarBG.x - timeText.width, timeBarBG.y + timeBarBG.width);
    }

    function resetVariables()
    {
        timeBar.value = 0;
        songPercentage = 0;
    }
    

    function verticalTimeBar()
    {

        timeBarBG.setPosition(FlxG.width - (timeBarBG.height / 2), (FlxG.height / 2) - (timeBarBG.width / 2));
        timeBarBG.origin.set(0, 0);
        timeBarBG.angle = 90;

        timeBar.setPosition(timeBarBG.x - 4, timeBarBG.y + 4);
        timeBar.origin.set(0, 0);
        timeBar.angle = 90;
        timeBar.flipX = true;

    

    }



    // function updateTime()
    // {
    //     curtime = FlxMath.roundDecimal(Conductor.instance.songPosition / 1000, 0);
    //     var timeleft = 0;

    //     if (FlxG.sound.music != null)
    //     {
    //         timeleft = FlxMath.roundDecimal(FlxG.sound.music.length / 1000, 0);

    //     }
    //     // idea taken from coolhud (i couldn't find a way to properly do it without lagging the game)
    //     switch (FlxG.save.data.timeBarmode)
    //     {
    //         case "None":
            
    //         case "Time Elapsed":
    //             timeText.text = FlxStringUtil.formatTime(curtime, false);

            
    //         case "Time Left":
    //             timeText.text = FlxStringUtil.formatTime(timeleft - curtime, false);

            
    //     }

    //     // stupid workaround but its okay
    //     if (Conductor.instance.songPosition < 0)
    //     {
    //         timeText.text = "0:00";
    //     }

    // }

    // function customtimeBar()
    // {
    //     timeBarBG.loadGraphic(Paths.image("timeBar"));
    //     timeBarBG.setGraphicSize(timeBar.width + 8, timeBar.height + 8);
    //     timeBarBG.updateHitbox();
    //     timeBarBG.setPosition(timeBar.x - 4, timeBar.y - 4);
    //     timeBarBG.antialiasing = false;
    // }
}
